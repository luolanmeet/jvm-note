### 对象的生命周期

##### 实例化对象的方式

* 明确使用 `new`操作符
* 调用`Class`或是`Constructor`对象的`newInstance`方法
* 调用现有对象的`clone`方法
* 通过`ObjectInputStream`类的`getObject`方法反序列化

##### 实例化对象的过程

* 在堆中为对象分配内存
  * <a href = "#为对象分配内存">为对象分配内存</a>
* 将实例变量初始化为默认值（和类变量初始化类似，这里是实例的变量）
* 为实例变量赋予正确的初始值
  * <a href = "#为对象分配内存">为对象赋值</a>
* 对象终结，被垃圾收集器回收
  * 如果类声明了一个`finalize`终结方法，垃圾收集器会在释放这个实例占据的内存前执行这个方法。

----

##### <a name = "为对象分配内存">为对象分配内存</a>

对象所需的内存大小在类加载完毕后便可以确定，

为对象分配空间实际上等同于把一块确定大小的内存从`Java`堆中划分出来。

###### 指针碰撞（Bump The Poiner）

假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的放在另一边，

中间使用一个指针作为分界点的指示器，那分配内存就只是将指针往空闲空间方向移动

和对象大小相等的距离即可。

###### 空闲列表（Free List）

若已使用和未使用的内存交错在一起，虚拟机就必须维护一个列表，记录哪些内存块是

可用的。分配内存时先查找列表，找到一块空间分给对象，然后更新列表。

###### 分配方式的选择

实际上取决于堆是否规则，堆是否规则取决于使用的垃圾收集器是否具有空间压缩整理（Compact）能力。

如 `Serial`、`ParNew`。使用了这些虚拟机，分配的方式将是指针碰撞，否则理论上只能是空闲列表。

----

##### <a name = "为对象赋值">为对象赋值</a>

* 如果通过`clone`方法，则将被克隆的实例的值拷贝到新的实例
* 如果通过`ObjectInputStream`的`readObject`方法，则通过流中读入的值来初始化
* 否则，调用对象的实例初始化方法`<init>`

> Java编译器为它编译的每一个类至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法称为`<init>`。针对一个类的构造方法，Java编译器都产生一个`<init>`方法。若不声明任何构造方法，则会默认产生一个无参数的构造方法。