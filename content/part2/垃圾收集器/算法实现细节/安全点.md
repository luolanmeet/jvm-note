### 安全点

在`OopMap`的协助下，`HotSpot`可以快速准确地完成`GC Roots`枚举。



#### 问题

可能导致`OopMap`内容变化的指令非常多，如果为每一条指令都生成对应的`OopMap`，

那将需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会非常高昂。



#### 安全点（Safepoint）

实际上`HotSpot`没有为每条指令生成**`OopMap`，只在安全点（`Safepoint`）生成**。

由于垃圾收集而需要停止用户线程时，用户线程不能在任意的地方暂定，必须到达安全点才能暂停。

##### 安全点的选择

安全点位置的选择基本是以“是否具有让程序长时间执行的特征”为标准指定的，如：

* 方法调用
* 循环跳转
* 异常跳转



#### 如何让线程都跑到最近安全点

这里不包括`JNI`调用的线程

* 抢占式中断（`Preemptive Suspension`）

> 在垃圾收集发生时，系统首先将所有用户线程中断，如果发现
>
> 用户线程不在安全点上，就恢复这个线程，直到跑到安全点上。
>
> 几乎没有虚拟机使用这种方式。

* 主动式中断（`Voluntary Suspension`）

> 设置一个标志位，每个线程执行过程时会不停地轮询这个标识，
>
> 一旦发现标志位为真时就自己在最近的安全点上主动挂起。
>
> 轮询标志位和安全点是重合的（到了安全点就轮询一次），
>
> 另外在所有创建对象和需要在堆上分配内存的地方也会轮询，
>
> 检查是否即将发生垃圾收集，防止没有足够内存分配对象。

`HotSpot`使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令。// TODO 这是啥