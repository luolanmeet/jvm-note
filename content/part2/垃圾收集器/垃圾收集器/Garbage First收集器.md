### Garbage First收集器

Garbage First 收集器简称`G1`，是垃圾收集器技术发展史上的里程碑式的成果，

开创了收集器面向局部收集的设计思路和基于`Region`的内存布局形式。

`G1`是一款主要面向服务端应用的垃圾收集器，被赋予替代`CMS`的期望。

`JDK9`发布后，`G1`宣告取代了`Parallel Scavenge + Parallel Old`组合，

成为收集器服务端模式下的默认垃圾收集器，而`CMS`则被声明为不推荐使用（`Deprecate`）。



#### 特色

> 停顿时间模型（`Pause Prediction Model`）：意思是能够支持指定在一个长度为M毫秒的时间片段内，
>
> 消耗在垃圾收集器上的时间大概率不超过N毫秒这样的目标。

设计者们希望`G1`是一款能够建立停顿时间模型的收集器，

以外的收集器垃圾收集的范围要么是整个新生代（`Minor GC`），要么是整个老年代（`Major GC`）,

要么是整个堆（`Full GC`）。而`G1`不是，它可以面向堆内存任何部分来组成回收集合（`Collection Set`，简称`CSet`）

进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，

这就是`G1`收集器的`Mixed GC`模式。



#### 基于`Region`的堆内存布局

`G1`开创的基于`Region`的堆内存布局是`G1`能建立停顿时间模型的关键。

`G1`也仍然遵循分代收集理论设计，但不再坚持固定大小以及固定数量的分代区域划分，

而是把连续的`Java`堆划分为多个大小相等的独立区域（`Region`），每一个`Region`都可以

根据需要扮演新生代的`Eden`空间、`Survivor`空间，或者是老年代空间。

收集器能够对扮演不同角色的`Region`采用不同的策略去处理。

`Region`中还有一类特殊的`Humongous`区域，专门用来存储大对象。`G1`认为大小超过一个`Region`

容量一半的对象即可判定为大对象。每个`Region`的大小可以通过`-XX:G1HeapRegionSize`设定，

取值范围为`1MB~32MB`，且应为2的`N`次幂。对于那些超过整个`Region`容量的超级大对象，将会

存放在`N`个连续的`Humongous Region`之中，`G1`的大多数行为都把`Humongous Region`作为老年代

的一部分进行看待。

![](img\G1 收集器Region分区示意图.png)

[图片来源链接](https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All/)



#### 能建立可预测的停顿时间模式的原因

是因为`G1`将`Region`作为单次回收的最小单元，即每次收集到的内存空间都是`Region`大小的整数倍，

这样可以有计划地避免在整个`Java`堆中进行全区域的垃圾收集。

具体思路就是让`G1`收集器跟踪各个`Region`里边的垃圾堆积的“价值”大小，价值即回收所获得的空间大小

以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间

（使用`-XX:MaxGCPauseMillis`指定，默认是200毫秒），优先处理回收价值收益最大的那些`Region`，

这也是`Garbage First`名字的由来。

> 是有标记过吗，不然怎么知道回收的价值。



#### `G1`实现难点及方案

##### 跨代应用的实现

将`Java`堆分成多个独立的`Region`后，`Region`里边存在跨`Region`引用对象同样也需要使用记忆集来避免

全堆作为`GC Root`扫描，`G1`的记忆集复杂得多，每个`Region`都维护自己的记忆集，这些记忆集会记录

别的`Region`指向自己的指针，并标记这些指针分别在哪些卡页的范围内。

`G1`的记忆集在存储结构的本质上是一种哈希表，`key`是别的`Region`的起始地址，`value`是一个集合，

存储的元素是卡表的索引号。这种双向的卡表结构（卡表是“我指向谁”，这种结构还记录了谁指向我）

比原来的卡表实现更复杂，同时由于`Region`数量比传统收集器的分代数量明显要多得多，因此`G1`收集器

要比其他传统垃圾收集器有着更高的内存中用负担。至少要耗费相当于`Java`堆容量10%至20%的额外内存来维持工作。

> 每个`Region`都维护自己的记忆集是怎么理解？
>
> > 之前的卡表的例子是一个字节数组， `CARD_TABLE [];`
> >
> > 现在是有多个某种数据结构吗？那岂不是需要遍历所有的`Regin`的记忆集吗？
> >
> > 之前是只有年轻代建立了卡表，用于标记老年代哪块内存中存在指向新生代的应用。
> >
> > 现在是新生代和老年代都有了吗？
>
> 双向要怎么理解？这里的我是代表啥？是`Region`吗？
>
> > 原来的卡表表达的意思就是某个内存中存在跨代引用的指针，即我指向谁。
> >
> > 对于一个`Region`来说，key是别的`Region`的起始地址，即谁指向了我（哪个内存中有对象引用了我这个Region中的对象）。
> >
> > `value`是卡表的索引值（最终要靠卡表找到卡页，才能找到需要扫描的内存）