### Java与线程

> `Thread`类与大部分的`Java`类库`API`有明显区别，所有关键方法都声明为`Native`。
>
> 在`Java`类库`API`中，一个`Native`方法往往就意味这这个方法没有使用或无法使用
>
> 平台无关的手段来实现。（也可能是为了执行效率而使用`Native`方法）

#### 线程的实现

* 内核线程实现（`1:1`实现）
* 用户线程实现（`1:N`实现）
* 用户线程+轻量级进程混合实现（`N:M`实现）



#### Java线程的实现

`HotSpot`的每个线程都是直接映射到一个操作系统原生线程来实现。（采用`1:1`的线程模型）

`HotSpot`自己不会干涉线程调度，全权交给操作系统去处理，何时冻结或唤醒线程、该给线程

分配多少处理器时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，

也都是由操作系统全权决定的。



#### Java线程调度

Java使用的线程调度方式是抢占时调度。

Java线程调度是系统自动完成的，但可以“建议”操作系统给某些线程多分配一些时间。

> 调优点？



#### 线程状态转化

`Java`语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态。

* 新建（`New`）：创建后尚未启动的线程处于这种状态。

* 运行（`Runnable`）：包括操作系统线程状态中的`Running`和`Ready`。

* 无限期等待（`Waiting`）：处于这种状态的线程不会被分配处理器执行时间，需要等待其他

  线程显示唤醒。以下方法会让线程进入无限期的等待状态。

  * 没有设置`Timeout`参数的`Object::wait()`方法
  * 没有设置`Timeout`参数的`Thread::join()`方法
  * `LockSupport::park()`方法