### Java内存模型与线程

在许多场景下，让计算机同时去做几件事情，不仅是因为计算机的运算能力很强大，

还有就是计算机的运算速度与它的存储和通信子系统速度差距太大，大量的时间花费

在磁盘I/O、网络通信或数据库访问上。



#### 并发场景

衡量一个服务性能的高低好坏，每秒事务处理数（`Transactions Per Second，TPS`）是

重要的指标之一，它代表着一秒内服务端平均响应的请求总数，而`TPS`值与程序的并发

能力又有非常密切的关系。



#### 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统

都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（`Cache`）来作为

内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算

结束后再从缓存同步会内存中，这样处理器就无须等待缓慢的内存读写了。

##### 缓存一致性问题

基于告诉缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但也引入了一个新的

问题：缓存一致性（`Cache Coherence`）。

在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（`Main Memory`），

这种系统称为共享内存多核系统（`Shard Memory Multiprocessors System`）。

当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。

##### 解决方式

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议

来进行操作，这类协议有`MSI`、`MESI`、`MOSI`、`Synapse`、`Firefly`及`Dragon Protocol`等。

##### 指令重排

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对

输入的代码进行乱序执行（`Out-Of-Order Execution`）优化，处理器会在计算之后将乱序执行

的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后

顺序与输入代码中的顺序一致。

