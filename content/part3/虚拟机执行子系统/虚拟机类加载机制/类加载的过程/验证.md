### 验证

这一步的目的是确保`Class`文件的字节流中包含的信息符合《Java虚拟机规范》的全部要求，

保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

验证阶段在虚拟机的类加载过程中占了相当大的比重。

验证阶段大致上会完成下边四个阶段的检验动作

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证



#### 文件格式验证

验证字节流是否符合`Class`文件格式的规范，并且能被当前虚拟机处理。包括：

* 是否以魔数`0xCAFEBABE`开头
* 主、次版本号是否在当前`Java`虚拟机接受范围之内
* 常量池的常量中是否有不被支持的常量类型（检测常量标识`tag`）
* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
* `CONSTANT_Utf8_info`型的常量中是否有不符合`UTF-8`编码的数据
* `Class`文件中各个部分及文件本身是否有被删除的或附加的其他信息
* ...

只有通过这个阶段的验证之后，字节流才允许进入`Java`虚拟机内存的方法区中存储，

后边的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读、操作字节流了。



#### 元数据验证

对字节码描述的信息进行语义分析，保证其描述的信息符合《Java语言规范》的要求。包括：

* 这个类是否有父类（出了`java.lang.Object`，所有类都应当有父类）
* 这个类的父类是否继承了不允许被继承的类（被`final`修饰的类）
* 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
* 类中的字段、方法是否与父类产生矛盾（覆盖了父类的`final`字段）
* ...



#### 字节码验证

是最复杂的一个阶段。主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。

这个阶段就要对类的方法体（`Class`文件中的`Code`属性）进行校验分析。

* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。

  例如不会出现操作数栈放置了一个`int`类型的数据，使用时却按照`long`来加载到本地变量表中。

* 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。

* 保证方法体中的类型转换总是有效的。

* ...



#### 符号引用验证

最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在

连接的第三阶段——解析阶段发生。

> 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的各类信息进行
>
> 匹配性校验，通俗来说就是该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

* 符号引用中通过字符串描述的全限定名是否能找到对应的类。
* 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
* 符号引用中的类、字段、方法的可访问性（`private`、`protected`、`public`、`<package>`）是否可被当前类访问。
* ...

符号引用验证的主要目的是确保解析行为能正常执行。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部

加载的、动态生成的等）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用`-Xverify:none`参数来关闭

大部分的类验证措施，以缩短虚拟机类加载的时间。