### 分派调用

`Java`是一门面向对象的程序语言，因为`Java`具备面向对象的3个基本特征

封装、继承、多态。分派调用将揭示多态的一些体现，如重载和重写。



#### 静态分派

##### 静态类型 & 动态类型

 ```java
/**
 * 静态分派
 * 重载
 */
public class StaticDispatch {

    static abstract class Human { }

    static class Man extends Human { }

    static class Woman extends Human { }

    public void sayHello (Human guy) {
        System.out.println("hello guy");
    }

    public void sayHello (Man guy) {
        System.out.println("hello gentleman");
    }

    public void sayHello (Woman guy) {
        System.out.println("hello lady");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man); 
        sr.sayHello(woman);
    }
}
// 结果
hello guy
hello guy
 ```

上边的代码中，`Human`称为变量的“静态类型”（`Static Type`），或者叫“外观类型”（`Apparent Type`），

后面的`Man`则被称为变量的“实际类型”（`Actual Type`）或者叫“运行时类型”（`Runtime Type`）。

静态类型和实际类型在程序中都可能发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身

的静态类型不会被改变，并且最终的静态类型是在编译期可知的；

```java
// 静态类型在使用时发生变化
sr.sayHello((Man) man); // hello gentleman
sr.sayHello((Woman) woman); // hello lady
```

而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

##### 执行结果的解释

虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的。由于静态类型在编译期可知，

所以在编译阶段`javac`编译器就根据静态类型决定了会使用哪个重载版本。

所有依赖静态类型来决定方法执行版本的分派动作，都被称为静态分派。静态分派的最典型应用

表现就是方法重载。

##### 重载的细节

需要注意`javac`编译器虽然能确定方法的重载版本，但在很多情况下是确定一个“相对更合适”的版本。

产生这种模糊结论的主要原因是字面量天生的模糊性，它不需要定义，所以字面量就没有显示的静态类型，

它的静态类型只能通过语言、语法的规则去理解和判断。